C语言知识
==========

内存的三总线
===============
::

	32位系统指的是32位数据线,但是一般地址线也是32位的
	这个地址线32位决定了内存地址只能有32位二进制（2^32，也就是4G）

什么是内存三总线
-----------------
- 地址线 
- 数据线 
- 控制总线

内存三总线是如何工作的
-----------------------
::

	向内存中写入一个数据的过程：
		1.控制总线上写指令
		2.地址总线上传输内存地址，
		3.数据总线上则传输要写入内存的数据。
	总结：
		控制总线上写指令，地址总线上传输内存地址，而数据总线上则传输要写入内存的数据。
		多少位CPU代表的就是数据总线位数。数据线越多，一次传输处理的数据就越多，性能就越好
		地址线的数量决定了它可以寻址内存空间的大小。如果是32位的，那么有32根地址线。则可寻址的内存大小为:2^32(4G)
		
内存和数据结构的关系
=====================

内存编址是以字节为单位
----------------------
::

	无论多少位的内存，都是以字节(1字节等于8位)为单位进行内存贬值的	
	如果是64位位宽内存的编制，那么表示在一定时间(时间指的是一个时钟周期)内所能传送数据的位数是64位,
	也就是8个内存单元（8个字节 = 64位）

内存和数据结构的关系
----------------------
::
	
	在C语言中，数据类型的本质标识一个内存格子的长度和解释方法，
	也就是说定义变量的时候，到底需要给这个变量分配多大空间，按照什么样的方式去解析该空间
	在32位系统中，一次传输处理的数据是32位。
	所以在很多32位系统环境下,当定义了bool类型的变量时，我们基本用int 来替代。
	虽然bool只占用一个位，看似节省了内存。
	但是因为硬件是32位的，只有定义int型变量（在内存中恰好分配4个字节），
	这样才能让软件和硬件对于数据处理非常切合，工作效率提高。定义Int变量看似浪费了31个bit，但是效率高很多。
	int整形中的“整”体现在它和CPU本身的数据位宽是一样的，如32位的CPU,整形就是32位,int就是32位
	
C语言如何操作内存	
==================

C语言对内存地址的封装
======================
C语言对内存地址的封装
----------------------
::
	
	int a; a = 5; a += 4;
	其中int a 代表的是编译器给我们分配了1个int 类型的内存格子(一共4个格子，每个格子一个字节)
	分配的这个内存格子，地址编译器是知道的,并且把a和这个内存地址绑定起来
	a = 5代表把5这个值扔到a绑定的那个地址所代表的的内存格子中。
	a += 4代表要加值，这个时候把a所绑定的地址中将数据取出来，并和4相加，
	再把所得的值扔到a绑定的那个地址所代表的的内存格子中

C语言中数据结构的本质含义
--------------------------
- 表示一个内存格子的长度和解析方法

数据类型决定长度的含义
-----------------------
::

	我们有一个内存地址(0x40000000)，这个地址代表的是一个字节的长度,
	但是我们可以给它一个类型，如(int)，
	那么这个内存地址0x40000000就能表示从这个数字(0x40000000)开头的连续的n(4)个字节的内存格子了.
	这个时候这个地址代表的大小是(0x40000000 + 0x40000001 + 0x40000002 + 0x40000003)。
	
数据类型决定解析这个数的方法的含义
-----------------------------------
::
	
	比如我有一个内存地址(0x40000000),我们可以通过给这个内存地址不同的类型以确定这个内存单元格子的解析方法。
	比如(int)0x40000000，含义就是(0x40000000 + 0x40000001 + 0x40000002 + 0x40000003)这4个字节连起来共同存储的是一个int型数据。
	那么如果(float)0x40000000，含义就是(0x40000000 + 0x40000001 + 0x40000002 + 0x40000003)这4个字节连起来共同存储的是一个float型数据。

总结
-------
- 内存单元格子的编址单元就是字节。
- 在C语言中，函数就是一段代码的封装，而函数名的实质就是这一段代码的首地址，所以说函数名的本质就是一个内存地址。

用指针来间接访问内存
=====================

::

	类型只是对后面的数字或者符号(代表的是内存地址)所表征的内存的一种长度规定和解析方法而已
	数组管理内存和变量其实没有本质区别，只是符号的解析方法不同。
	如定义一个int a 和 int b[10]是不一样的
	int a:编译器分配4个字节给a,并且把首地址和符号a绑定起来 
	int b[10]:编译器分配 4 * 10 个字节给b，并且把首地址和符号b绑定起来 	
	数组b中，第一个元素b[0]就称为首元素,每一个元素都占用4个字节(int),
	其中第一个字节地址就称为首地址,首元素b[0]的首地址就称为首元素首地址。

结构体内嵌指针实现面向对象
===========================
::

	struct s
	{
		int age;					// 普通变量
		void (*pFunc)(void);		// 函数指针，指向 void func(void)这类的函数
	};
	这样包含了函数指针和普通变量的结构体就类似于面向对象中的class结构体
	其中变量类似于class中的成员变量,函数指针就类似于class中的成员方法